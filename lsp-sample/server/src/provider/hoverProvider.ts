import { Hover } from 'vscode-languageserver';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';
import { 
	ControlDeclarationContext,
	ParserDeclarationContext,
	ActionDeclarationContext,
	NameContext,
	VariableDeclarationContext,
	ConstantDeclarationContext,
	ParserTypeDeclarationContext,
	ControlTypeDeclarationContext
} from '../antlr_autogenerated/P4grammarParser';
import { RuleNode } from 'antlr4ts/tree/RuleNode';
import { ParseTreeWalker } from 'antlr4ts/tree/ParseTreeWalker';
import { ParseTree } from 'antlr4ts/tree/ParseTree';
import { HOVER_LISTENER } from '../compiler/antlr4ts_proxy';
import { HoverListener } from '../listeners/HoverListener';

// interface to give back the largest context scope
interface CurrentNodeContext {
	isGlobal: boolean,
	name: string,
}

export function getHoverContent(index: number): Hover | undefined {

	let content: string | undefined;
	let currentToken: TerminalNode | undefined = getCurrentToken(index, HOVER_LISTENER!.nodeList);
	let currentRuleNode: RuleNode | undefined = currentToken?._parent;
	let hoverResult: CurrentNodeContext | undefined = isGlobalRule(currentRuleNode);

	if(tokenIsDeclaration(currentRuleNode)) {
		if(!hoverResult?.isGlobal) {
			content = hoverResult?.name;
		} else {
			content = `${currentRuleNode!.text} is a global variable`;
		}
	}

	return {
		contents: content!
	} 
}

// a context array to take all the declaration context objects
let contextArray = [ControlDeclarationContext, ParserDeclarationContext, ActionDeclarationContext];

// get the actual token on which the hover is on
export function getCurrentToken(index: number, list: TerminalNode[]): TerminalNode | undefined {

	if(list.length !== 0){
		for(let token of list) {
			if((index == token._symbol.startIndex && index == token._symbol.stopIndex) || (index <= token._symbol.stopIndex && index >= token._symbol.startIndex)) {
				return token;
			}
		}
	}
	return undefined;
}

// check wether a token is a variable declaration
export function tokenIsDeclaration(rule: RuleNode | undefined): boolean {
	
	while(rule !== undefined) {
		if(rule instanceof NameContext && (rule.parent instanceof VariableDeclarationContext || rule.parent instanceof ConstantDeclarationContext)) {
			return true;
		}
		rule = rule.parent;
	}
	return false;
}

// check wether a token belongs to a local declaration scope
export function isGlobalRule(rule: RuleNode | undefined): CurrentNodeContext | undefined {

	if(rule === undefined) {
		return undefined;	
	}

	while(rule !== undefined) {
		for(let ctx of contextArray) {
			if(rule instanceof ctx) {
				return {
					isGlobal: false,
					name: getChildContent(rule)
				};
			}
		}
		rule = rule.parent;
	}

	return {
		isGlobal: true,
		name: ''
	};
}

export function getChildContent(rule: RuleNode | undefined): string {

	let result: string = '';
	let exceptionChars: string[] = ['(', ')', ',', '{' , '}', ';'];

	let newListener = new HoverListener();
	let newList: string[] = newListener.textList;

	let goodNode: ParseTree | undefined;

	for(let i = 0; i < rule?.childCount!; i++){
		if(rule?.getChild(i) instanceof ParserTypeDeclarationContext || rule?.getChild(i) instanceof ControlTypeDeclarationContext){
			goodNode = rule.getChild(i);
			break;
		}
	}

	ParseTreeWalker.DEFAULT.walk(newListener, goodNode!);

	for(let i = 0; i <= newList.length-1; i++) {
		let str: string = newList[i];
		if(exceptionChars.includes(str) || exceptionChars.includes(newList[i+1])) {
			if(str === ',' || str === ';'){
				result += str + ' ';
			} else {
				result += str;
			}
		} else {
			result += str + ' ';
		}
	}

	return result;
}