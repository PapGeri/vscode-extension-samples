import { Hover } from 'vscode-languageserver';
import { MY_LISTENER } from '../compiler/antlr4ts_proxy';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';
import { ControlDeclarationContext, ParserDeclarationContext, ActionDeclarationContext, NameContext } from '../antlr_autogenerated/P4grammarParser';
import { RuleNode } from 'antlr4ts/tree/RuleNode';

// interface to give back the largest context scope
interface CurrentNodeContext {
	isGlobal: boolean,
	name: string,
}

export function getHoverContent(index: number): Hover | undefined {

	let content: string | undefined;
	let currentToken: TerminalNode | undefined = getCurrentToken(index);
	let currentRuleNode: RuleNode | undefined = currentToken?._parent;

	let hoverResult = isGlobalRule(currentRuleNode);

	if(tokenIsDeclaration(currentRuleNode)) {
		if(!hoverResult.isGlobal) {
			content = hoverResult.name;
		} else {
			content = `${currentRuleNode!.text} is a global variable`;
		}
	} 

	return {
		contents: content!
	} 
}

// a context array to take all the declaration context objects... Not a good idea/solution
let contextArray = [ControlDeclarationContext, ParserDeclarationContext, ActionDeclarationContext];
// let ruleNames: string[] = P4grammarParser.ruleNames;
// console.log(ruleNames);

// check wether a token belongs to a local declaration scope
function isGlobalRule(rule: RuleNode | undefined): CurrentNodeContext {

	while(rule !== undefined) {
		for(let ctx of contextArray) {
			if(rule instanceof ctx) {
				console.log(`its false because it is a : ${rule.text}`)
				return {isGlobal: false, name: rule.getChild(0).text};
			}
		}
		rule = rule.parent;
	}
	return {isGlobal: true, name: ''};
}

// check wether a token is a variable declaration
function tokenIsDeclaration(rule: RuleNode | undefined): boolean {
	
	while(rule !== undefined) {
		if(rule instanceof NameContext) {
			return true;
		}
		rule = rule.parent;
	}
	return false;
}

// get the actual token on which the hover is on
function getCurrentToken(index: number): TerminalNode | undefined {

	for(let token of MY_LISTENER!.list) {
		if((index == token._symbol.startIndex && index == token._symbol.stopIndex) || (index <= token._symbol.stopIndex && index >= token._symbol.startIndex)) {
			return token;
		}
	}
	return undefined;
}