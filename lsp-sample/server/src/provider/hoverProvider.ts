import { Hover, Diagnostic } from 'vscode-languageserver';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';
import { 
	ControlDeclarationContext,
	ParserDeclarationContext,
	ActionDeclarationContext,
	NameContext,
	VariableDeclarationContext,
	ConstantDeclarationContext,
	ParserTypeDeclarationContext,
	ControlTypeDeclarationContext
} from '../antlr_autogenerated/P4grammarParser';
import { RuleNode } from 'antlr4ts/tree/RuleNode';
import { ParseTreeWalker } from 'antlr4ts/tree/ParseTreeWalker';
import { ParseTree } from 'antlr4ts/tree/ParseTree';
import { HOVER_LISTENER } from '../compiler/antlr4ts_proxy';
import { HoverListener } from '../listeners/HoverListener';

// interface to give back the largest context scope
interface CurrentNodeContext {
	isGlobal: boolean,
	name: string,
}

export function getHoverContent(index: number): Hover | undefined {

	let content: string | undefined;
	let currentToken: TerminalNode | undefined = getCurrentToken(index);
	let currentRuleNode: RuleNode | undefined = currentToken?._parent;
	let hoverResult: CurrentNodeContext = isGlobalRule(currentRuleNode);

	if(tokenIsDeclaration(currentRuleNode)) {
		if(!hoverResult.isGlobal) {
			content = hoverResult.name;
		} else {
			content = `${currentRuleNode!.text} is a global variable`;
		}
	}

	return {
		contents: content!
	} 
}

// a context array to take all the declaration context objects
let contextArray = [ControlDeclarationContext, ParserDeclarationContext, ActionDeclarationContext];

// get the actual token on which the hover is on
function getCurrentToken(index: number): TerminalNode | undefined {

	for(let token of HOVER_LISTENER!.nodeList) {
		if((index == token._symbol.startIndex && index == token._symbol.stopIndex) || (index <= token._symbol.stopIndex && index >= token._symbol.startIndex)) {
			return token;
		}
	}
	return undefined;
}

// check wether a token is a variable declaration
function tokenIsDeclaration(rule: RuleNode | undefined): boolean {
	
	while(rule !== undefined) {
		if(rule instanceof NameContext && (rule.parent instanceof VariableDeclarationContext || rule.parent instanceof ConstantDeclarationContext)) {
			return true;
		}
		rule = rule.parent;
	}
	return false;
}

// check wether a token belongs to a local declaration scope
function isGlobalRule(rule: RuleNode | undefined): CurrentNodeContext {

	while(rule !== undefined) {
		for(let ctx of contextArray) {
			if(rule instanceof ctx) {
				return {isGlobal: false, name: getChildContent(rule)};
			}
		}
		rule = rule.parent;
	}
	return {isGlobal: true, name: ''};
}

function getChildContent(rule: RuleNode | undefined): string {

	let resultStr: string = '';
	let newListener = new HoverListener();
	let newList: string[] = newListener.textList;

	let goodNode: ParseTree | undefined;

	for(let i = 0; i < rule!.childCount; i++){
		if(rule?.getChild(i) instanceof ParserTypeDeclarationContext || rule?.getChild(i) instanceof ControlTypeDeclarationContext){
			goodNode = rule.getChild(i);
			break;
		}
	}

	ParseTreeWalker.DEFAULT.walk(newListener, goodNode!);

	// itt azt nezem hogy a kovetkezo elem az egy karakterbol all-e hogy jol nezzen ki a hover spaceingje
	// jobb lenne egy listaba kigyujteni az elemeket ahol nem kell space pl. (, ), ;, ,,
	// WIP == needs working

	// talan kulon function ami ezt megcsinalja, valahogy newLine-t ha { vagy ; a krarketer

	for(let index = 0; index < newList.length; index++){
		if(index === 0){
			resultStr += newList[index];
		}
		else if(newList[index].length < 2) {
			resultStr += newList[index];
		} else {
			resultStr += ' ' + newList[index];
		}
	}

	return resultStr;
}