import { Hover } from 'vscode-languageserver';
import { MY_LISTENER } from '../compiler/antlr4ts_proxy';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';
import { 
	ControlDeclarationContext,
	ParserDeclarationContext,
	ActionDeclarationContext,
	NameContext,
	VariableDeclarationContext,
	ConstantDeclarationContext,
	ParserTypeDeclarationContext,
	ControlTypeDeclarationContext
} from '../antlr_autogenerated/P4grammarParser';
import { RuleNode } from 'antlr4ts/tree/RuleNode';
import { ParseTreeWalker } from 'antlr4ts/tree/ParseTreeWalker';
import { MyListener } from '../compiler/MyListener';
import { ParseTree } from 'antlr4ts/tree/ParseTree';

// interface to give back the largest context scope
interface CurrentNodeContext {
	isGlobal: boolean,
	name: string,
}

export function getHoverContent(index: number): Hover | undefined {

	let content: string | undefined;
	let currentToken: TerminalNode | undefined = getCurrentToken(index);
	let currentRuleNode: RuleNode | undefined = currentToken?._parent;

	let hoverResult: CurrentNodeContext = isGlobalRule(currentRuleNode);

	if(tokenIsDeclaration(currentRuleNode)) {
		if(!hoverResult.isGlobal) {
			content = hoverResult.name;
		} else {
			content = `${currentRuleNode!.text} is a global variable`;
		}
	} 

	return {
		contents: content!
	} 
}

// a context array to take all the declaration context objects... Not a good idea/solution
let contextArray = [ControlDeclarationContext, ParserDeclarationContext, ActionDeclarationContext];

// get the actual token on which the hover is on
function getCurrentToken(index: number): TerminalNode | undefined {

	for(let token of MY_LISTENER!.list) {
		if((index == token._symbol.startIndex && index == token._symbol.stopIndex) || (index <= token._symbol.stopIndex && index >= token._symbol.startIndex)) {
			return token;
		}
	}
	return undefined;
}

// check wether a token is a variable declaration
function tokenIsDeclaration(rule: RuleNode | undefined): boolean {
	
	while(rule !== undefined) {
		if(rule instanceof NameContext && (rule._parent instanceof VariableDeclarationContext || rule._parent instanceof ConstantDeclarationContext)) {
			return true;
		}
		rule = rule.parent;
	}
	return false;
}

// check wether a token belongs to a local declaration scope
function isGlobalRule(rule: RuleNode | undefined): CurrentNodeContext {

	while(rule !== undefined) {
		for(let ctx of contextArray) {
			if(rule instanceof ctx) {
				console.log(`its a local variable!!!!`)
				return {isGlobal: false, name: getChildContent(rule)};
			}
		}
		rule = rule.parent;
	}
	return {isGlobal: true, name: ''};
}

function getChildContent(rule: RuleNode | undefined): string {

	let resultStr: string = '';
	let newListener = new MyListener();
	
	let goodNode: ParseTree | undefined;

	for(let i = 0; i < rule!.childCount; i++){
		if(rule?.getChild(i) instanceof ParserTypeDeclarationContext || rule?.getChild(i) instanceof ControlTypeDeclarationContext){
			goodNode = rule.getChild(i);
			break;
		}
	}

	ParseTreeWalker.DEFAULT.walk(newListener, goodNode!);
	for(let terminal of newListener.textList) {
		resultStr += terminal + ' ';
	}

	console.log(MY_LISTENER?.compList);
	return resultStr;
}