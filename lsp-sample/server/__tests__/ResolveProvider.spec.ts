import { CompletionResolveListener } from '../src/listeners/CompletionResolveListener';
import { getFileContentFromFileName, setupAntlr } from './utils';
import { P4grammarListener } from '../src/antlr_autogenerated/P4grammarListener';
import { CompletionItem } from 'vscode-languageserver';
import { getFormattedString, getDeclarationText } from '../src/provider/CompletionResolveProvider';
import { RuleContext } from 'antlr4ts';
import { StartContext } from '../src/antlr_autogenerated/P4grammarParser';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';

// beforeEach run listener es rulecontextet visszaadni 
// before, fajlt beparsolni antlr-el, itt meghivni a listener
const testItem: CompletionItem = {
	label: 'egress'
};

const ctx: RuleContext | undefined = {
	_parent: {} as StartContext,
	ruleContext: {
		text: 'string'
	} as TerminalNode,
} as unknown as RuleContext;

describe('Resolve Listener with empty file', () => {
	let resolveListener: CompletionResolveListener = new CompletionResolveListener();
	// let listeners: P4grammarListener[] = [resolveListener];
	const file: string = getFileContentFromFileName('empty.p4');
	setupAntlr(file, resolveListener);

	it('should have empty token list', () => {
		let terminalNodeList = resolveListener.tokenTextList;
		expect(terminalNodeList).toHaveLength(0);
	})
})

describe('Resolve listener with data', () => {
	let resolveListener: CompletionResolveListener = new CompletionResolveListener();
	// let listeners: P4grammarListener[] = [resolveListener];
	const file: string = getFileContentFromFileName('shortExample.p4');
	setupAntlr(file, resolveListener);

	it('should have tokens in the lists', () => {
		let nodeList = resolveListener.tokenTextList;
		expect(nodeList).toContain('egressSpec_t');
	})
})


describe('Resolve Provider testing', () => {
	let resolveListener: CompletionResolveListener = new CompletionResolveListener();
	// let listeners: P4grammarListener[] = [resolveListener];
	const file: string = getFileContentFromFileName('simpleSwitchExample.p4');
	setupAntlr(file, resolveListener);

	it('should complete the item', () => {

		let expected: string = 'struct Parsed_packet{Ethernet_h ethernet; IPv4_h ip; }';
		let context: RuleContext = resolveListener.compResolvMap.keys().next().value;
		let result: string = getDeclarationText(context);
		
		expect(expected).toEqual(result);
	});

	it('should give back a formatted string', () => {

		let expected: string = 'parser TopParser(packet_in b, out Parsed_packet p)';
		let testList: string[] = ['parser', 'TopParser', '(', 'packet_in', 'b', ',' , 'out', 'Parsed_packet', 'p', ')'];
		
		let result = getFormattedString(testList);
		expect(expected).toEqual(result);
	})
})



















// jest.mock('../src/provider/CompletionResolveProvider', () => {
// 	return {
// 		getDeclarationText: jest.fn().mockImplementation((ctx: RuleContext | undefined) => {
// 			if(ctx !== undefined){
// 				return ctx.text;
// 			}
// 		})
// 	}
// })

// jest.mock('antlr4ts/tree/ParseTreeWalker', () => {
// 	const DEFAULT = jest.fn();
// 	//DEFAULT.walk = jest.fn();
// 	return { DEFAULT };
// })

// describe('First test', () => {

// 	const ctx: RuleContext | undefined = {
// 		_parent: {} as StartContext,
// 		ruleContext: {
// 			text: 'string'
// 		} as TerminalNode,
// 	} as unknown as RuleContext;

// 	it('should work with the mocked rulecontext', () => {
		
// 		const result: string = getDeclarationText(ctx.ruleContext);

// 		expect(result).toBe('string');
// 	})
// });