import { getDeclarationText, CompletionResolveProvider } from '../src/provider/CompletionResolveProvider';
import { RuleContext } from 'antlr4ts/RuleContext';
import { TerminalNode } from 'antlr4ts/tree/TerminalNode';
import { StartContext } from '../src/antlr_autogenerated/P4grammarParser';
import { CompletionResolveListener } from '../src/listeners/CompletionResolveListener';
import { ParseTreeWalker } from 'antlr4ts/tree/ParseTreeWalker';

// beforeEach run listener es rulecontextet visszaadni 
// before, fajlt beparsolni antlr-el, itt meghivni a listener
// jest.mock('../src/listeners/CompletionResolveListener', () => {
// 	return {
// 		CompletionResolveListener: jest.fn().mockImplementation(() => {
// 			return {
// 				enterStart: () => {},
// 				visitTerminal: () => {}
// 			};
// 		})
// 	}
// })

// jest.mock('antlr4ts/tree/ParseTreeWalker', () => {
// 	return {
// 		ParseTreeWalker: jest.fn().mockImplementation(() => {
// 			return {
// 				enterRule: jest.fn(),
// 				exitRule: jest.fn(),
// 				walk: jest.fn(),
// 			}
// 		})
// 	}
// })

// jest.mock('../src/provider/CompletionResolveProvider', () => {
// 	return {
// 		CompletionResolveProvider: jest.fn().mockImplementation(() => {
// 			return {
// 				getDeclarationText: jest.fn().mockReturnValue('string')
// 			}
// 		})
// 	}
// })

jest.mock('../src/provider/CompletionResolveProvider', () => {
	return {
		getDeclarationText: jest.fn().mockImplementation((ctx: RuleContext | undefined) => {
			if(ctx !== undefined){
				return ctx.text;
			}
		})
	}
})

jest.mock('antlr4ts/tree/ParseTreeWalker', () => {
	const DEFAULT = jest.fn();
	//DEFAULT.walk = jest.fn();
	return { DEFAULT };
})


// jest.mock('../src/listeners/CompletionResolveListener', () => ({
// 	CompletionResolveListener: jest.fn().mockImplementation(() => {
// 	})
// }))

// jest.mock('antlr4ts/tree/ParseTreeWalker');
// (ParseTreeWalker as jest.Mock).mockImplementation(() => 'ParseTreeWalker');

describe('First test', () => {

	//const treeWalker: ParseTreeWalker = new ParseTreeWalker();

	//const testListener = new CompletionResolveListener();

	const ctx: RuleContext | undefined = {
		_parent: {} as StartContext,
		ruleContext: {
			text: 'string'
		} as TerminalNode,
	} as unknown as RuleContext;



	// it('should return variable documentation', () => {
		
	// 	const mock: ContextInfo = {
	// 		type: ContextDeclarationEnum.VARIABLE,
	// 		name: 'base'
	// 	};
	// 	const result: string = getDocumentation(mock);
	// 	expect(result).to.equal('This is a variable declaration');
	// });

	// it('should return true, as its empty', () => {

	// 	const mockCtx: RuleContext = new RuleContext();
	// 	const result : boolean = mockCtx.isEmpty;
	// 	expect(result).to.equal(true);
	// })

	it('should work with the mocked rulecontext', () => {
		
		const result: string = getDeclarationText(ctx.ruleContext);
		//expect(ParseTreeWalker.DEFAULT.walk).toHaveBeenCalledWith(CompletionResolveListener, ctx);

		expect(result).toBe('string');
	})
});